const numberOfLands = 51;
AFRAME.registerComponent('land-tick', {
    init() {

    },
    tick(time, timeDelta){

        // console.log('checking land position');
        for(let k = 1; k < numberOfLands; k++){
            var land = document.querySelector(`#land${k}`);
            var landPosition = land.getAttribute('position');
            var landx = landPosition.x;
            if (landx < -50){
                var newLandPosition = 483;
                land.setAttribute('position', {x: newLandPosition, y: 0.1, z: -3});
                console.log(`land${k} reset to ${newLandPosition}}`);
            }
        }
    }
  
});




console.log("lands.js loaded");
function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function terraForm() {   
var previousland = 1;
var landnum = 1
var nextXLocation = 0
    for(let k = 1; k < numberOfLands; k++){
        while(landnum == previousland)
        {landnum = getRandomInt(1,7); console.log("landID changed loop");}
      
        switch(landnum){
            case 1: landsize = 8; break;
            case 2: landsize = 8; break;
            case 3: landsize = 10; break;
            case 4: landsize = 10; break;
            case 5: landsize = 10; break;
            case 6: landsize = 14; break;
            case 7: landsize = 14; break;
        }
        nextXLocation += (landsize/2 + 5);
        landBuild(k, landnum, nextXLocation)
        previousland = landnum;
    }
   
}


function landBuild(id, landnumber, x){  
const game = document.querySelector('#game');
var halfextents = "";
switch(landnumber){
    case 1:halfextents = "x: 4, y: 2, z: 4"; break;
    case 2:halfextents = "x: 4, y: 2, z: 4"; break;
    case 3:halfextents = "x: 6, y: 4, z: 6"; break;
    case 4:halfextents = "x: 8, y: 8, z: 8"; break;
    case 5:halfextents = "x: 8, y: 8, z: 8"; break;
    case 6:halfextents = "x: 10, y: 10, z: 10"; break;
    case 7:halfextents = "x: 10, y: 10, z: 10"; break;
}
const land = document.createElement('a-entity');
land.setAttribute('id', `land${id}`);
land.setAttribute('gltf-model', `#${landnumber}`);
land.setAttribute('position', {x: x, y: 0.1, z: -10});
land.setAttribute('ammo-body', {type: 'kinematic', emitCollisionEvents: true});
land.setAttribute('ammo-shape', {type: 'box', fit: 'manual', halfExtents: `${halfextents}`, offset: {x: 0, y: 1, z: 0}});
land.setAttribute('activationState','active')
land.setAttribute('animation',{property: 'position', to: '-999 0 0', loop: false, dur: 100000});
game.appendChild(land);
console.log(`land${id} added with land ${landnumber} at location x = ${x}`);

}
terraForm();


 AFRAME.registerComponent('land-collide', {
    init: function() {
      // Get the geometry component of the "otherSprite" entity
      var otherGeometry = document.querySelector('#sprite').getAttribute('geometry');
      var thisGeometry = this.el.getAttribute('geometry');
      console.log(otherGeometry);
      console.log(thisGeometry);
    //  console.log(this.el.getAttribute('geometry'));
  
      // Set up the AABB collision detection component to check for collisions with the "otherSprite" entity
      this.el.setAttribute('aabb-collider', {objects: '#sprite'});
  
      // Set up a listener to check for collisions with the "otherSprite" entity
      this.el.addEventListener('collide', function(evt) {
        if (evt.detail.body.el.getAttribute('geometry') === otherGeometry) {
          console.log('Collision detected!');
        }
      });
    }
  });
  

  AFRAME.registerComponent('land-move', {

    // Initialize the component
    init: function () {
    },

    // Update the component on every animation frame
    tick: function (time, delta) { 
         var isPaused = this.el.getAttribute('paused');
        if (isPaused == false){
            // Set direction of the entity
            const direction = new THREE.Vector3(-51, 0, 0); 
            var speed = this.el.getAttribute('land-speed');
            this.el.velocity = new THREE.Vector3();
            this.el.velocity.addScaledVector(direction, speed);

            // Get the current position of the entity
            const position = this.el.object3D.position.clone();

            // Calculate the time since the last animation frame
            const dt = delta / 1000;

            // Update the position of the entity based on its velocity
            position.addScaledVector(this.el.velocity, dt);

            // Set the new position of the entity
            this.el.object3D.position.copy(position);
        }
        else{
            console.log('paused in tick');
            const direction = new THREE.Vector3(0, 0, 0); 
            var speed = this.el.getAttribute('land-speed');
            this.el.velocity = new THREE.Vector3();
            this.el.velocity.addScaledVector(direction, speed);

            // Get the current position of the entity
            const position = this.el.object3D.position.clone();

            // Calculate the time since the last animation frame
            const dt = delta / 1000;

            // Update the position of the entity based on its velocity
            position.addScaledVector(this.el.velocity, dt);

            // Set the new position of the entity
            this.el.object3D.position.copy(position);

        }
    },
    pause: function () {
        this.el.addEventListener('pause', () => {
            console.log('pausing');
        this.paused = true;
        this.el.velocity = new THREE.Vector3(0, 0, 0); // Set velocity to 0
        });

    },
    play: function () {
        this.el.addEventListener('play', () => {
            console.log('playing');
        this.paused = false;
        });
    }
});

AFRAME.registerComponent('jump', {
  init: function () {
    this.el.setAttribute('sprite-speed', 5);
    var speed = this.el.getAttribute('sprite-speed');
    const direction = new THREE.Vector3(0, 1, 0);
    const sprite = document.querySelector("#sprite");
    sprite.velocity = new THREE.Vector3();
    this.el.addEventListener('click', () => {
    sprite.velocity.addScaledVector(direction, speed);
    this.el.setAttribute('sprite-gravity', 9.8);
    });
  },
  tick: function (time, delta) { 
      const sprite = document.querySelector("#sprite");
      var pos = sprite.getAttribute(position)
      if (sprite.getAttribute('freeze') == 1) {
      var gravity = this.el.getAttribute('sprite-gravity');
      const position = sprite.object3D.position.clone();
      const dt = delta / 1000;
      sprite.velocity.y -= gravity * dt;
      position.addScaledVector(sprite.velocity, dt);
      sprite.setAttribute('current-velocity', sprite.velocity.y);
      if (position.y < 0) {
        position.y = 0;
        sprite.velocity.set(0, 0, 0);
      }
      if (position.y > 13) {
        position.y = 13;
        sprite.velocity.set(0, 0, 0);
      }
      sprite.object3D.position.copy(position);
    }
    
  },
 
});
