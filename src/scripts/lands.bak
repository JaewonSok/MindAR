const numberOfLands = 51;
AFRAME.registerComponent('land-tick', {
    init() {

    },
    tick(time, timeDelta){

        // console.log('checking land position');
        for(let k = 1; k < numberOfLands; k++){
            var land = document.querySelector(`#land${k}`);
            var landPosition = land.getAttribute('position');
            var landx = landPosition.x;
            if (landx < -50){
                var newLandPosition = 483;
                land.setAttribute('position', {x: newLandPosition, y: 0.1, z: -3});
                console.log(`land${k} reset to ${newLandPosition}}`);
            }
        }
    }
  
});




console.log("lands.js loaded");
function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function terraForm() {   
var previousland = 1;
var landnum = 1
var nextXLocation = 0
    for(let k = 1; k < numberOfLands; k++){
        while(landnum == previousland)
        {landnum = getRandomInt(1,7); console.log("landID changed loop");}
      
        switch(landnum){
            case 1: landsize = 8; break;
            case 2: landsize = 8; break;
            case 3: landsize = 10; break;
            case 4: landsize = 10; break;
            case 5: landsize = 10; break;
            case 6: landsize = 14; break;
            case 7: landsize = 14; break;
        }
        nextXLocation += (landsize/2 + 5);
        landBuild(k, landnum, nextXLocation)
        previousland = landnum;
    }
   
}


function landBuild(id, landnumber, x){  
const game = document.querySelector('#game');
var halfextents = "";
switch(landnumber){
    case 1:halfextents = "x: 4, y: 2, z: 4"; break;
    case 2:halfextents = "x: 4, y: 2, z: 4"; break;
    case 3:halfextents = "x: 6, y: 4, z: 6"; break;
    case 4:halfextents = "x: 8, y: 8, z: 8"; break;
    case 5:halfextents = "x: 8, y: 8, z: 8"; break;
    case 6:halfextents = "x: 10, y: 10, z: 10"; break;
    case 7:halfextents = "x: 10, y: 10, z: 10"; break;
}
const land = document.createElement('a-entity');
land.setAttribute('id', `land${id}`);
land.setAttribute('gltf-model', `#${landnumber}`);
land.setAttribute('position', {x: x, y: 0.1, z: -10});
land.setAttribute('ammo-body', {type: 'kinematic', emitCollisionEvents: true});
land.setAttribute('ammo-shape', {type: 'box', fit: 'manual', halfExtents: `${halfextents}`, offset: {x: 0, y: 1, z: 0}});
land.setAttribute('activationState','active')
land.setAttribute('animation',{property: 'position', to: '-999 0 0', loop: false, dur: 100000});
game.appendChild(land);
console.log(`land${id} added with land ${landnumber} at location x = ${x}`);

}
terraForm();


 AFRAME.registerComponent('land-collide', {
    init: function() {
      // Get the geometry component of the "otherSprite" entity
      var otherGeometry = document.querySelector('#sprite').getAttribute('geometry');
      var thisGeometry = this.el.getAttribute('geometry');
      console.log(otherGeometry);
      console.log(thisGeometry);
    //  console.log(this.el.getAttribute('geometry'));
  
      // Set up the AABB collision detection component to check for collisions with the "otherSprite" entity
      this.el.setAttribute('aabb-collider', {objects: '#sprite'});
  
      // Set up a listener to check for collisions with the "otherSprite" entity
      this.el.addEventListener('collide', function(evt) {
        if (evt.detail.body.el.getAttribute('geometry') === otherGeometry) {
          console.log('Collision detected!');
        }
      });
    }
  });
  

  AFRAME.registerComponent('land-move', {

    // Initialize the component
    init: function () {
    },

    // Update the component on every animation frame
    tick: function (time, delta) { 
         var isPaused = this.el.getAttribute('paused');
        if (isPaused == false){
            // Set direction of the entity
            const direction = new THREE.Vector3(-51, 0, 0); 
            var speed = this.el.getAttribute('land-speed');
            this.el.velocity = new THREE.Vector3();
            this.el.velocity.addScaledVector(direction, speed);

            // Get the current position of the entity
            const position = this.el.object3D.position.clone();

            // Calculate the time since the last animation frame
            const dt = delta / 1000;

            // Update the position of the entity based on its velocity
            position.addScaledVector(this.el.velocity, dt);

            // Set the new position of the entity
            this.el.object3D.position.copy(position);
        }
        else{
            console.log('paused in tick');
            const direction = new THREE.Vector3(0, 0, 0); 
            var speed = this.el.getAttribute('land-speed');
            this.el.velocity = new THREE.Vector3();
            this.el.velocity.addScaledVector(direction, speed);

            // Get the current position of the entity
            const position = this.el.object3D.position.clone();

            // Calculate the time since the last animation frame
            const dt = delta / 1000;

            // Update the position of the entity based on its velocity
            position.addScaledVector(this.el.velocity, dt);

            // Set the new position of the entity
            this.el.object3D.position.copy(position);

        }
    },
    pause: function () {
        this.el.addEventListener('pause', () => {
            console.log('pausing');
        this.paused = true;
        this.el.velocity = new THREE.Vector3(0, 0, 0); // Set velocity to 0
        });

    },
    play: function () {
        this.el.addEventListener('play', () => {
            console.log('playing');
        this.paused = false;
        });
    }
});

AFRAME.registerComponent('jump', {
  init: function () {
    this.el.setAttribute('sprite-speed', 5);
    var speed = this.el.getAttribute('sprite-speed');
    const direction = new THREE.Vector3(0, 1, 0);
    const sprite = document.querySelector("#sprite");
    sprite.velocity = new THREE.Vector3();
    this.el.addEventListener('click', () => {
    sprite.velocity.addScaledVector(direction, speed);
    this.el.setAttribute('sprite-gravity', 9.8);
    });
  },
  tick: function (time, delta) { 
      const sprite = document.querySelector("#sprite");
      var pos = sprite.getAttribute(position)
      if (sprite.getAttribute('freeze') == 1) {
      var gravity = this.el.getAttribute('sprite-gravity');
      const position = sprite.object3D.position.clone();
      const dt = delta / 1000;
      sprite.velocity.y -= gravity * dt;
      position.addScaledVector(sprite.velocity, dt);
      sprite.setAttribute('current-velocity', sprite.velocity.y);
      if (position.y < 0) {
        position.y = 0;
        sprite.velocity.set(0, 0, 0);
      }
      if (position.y > 13) {
        position.y = 13;
        sprite.velocity.set(0, 0, 0);
      }
      sprite.object3D.position.copy(position);
    }
    
  },
 
});


	// const sprite = document.querySelector("#sprite");
	// var oldSpeed = sprite.getAttribute('old-speed');
	// // sprite.setAttribute('sprite-speed', oldSpeed);
	// // sprite.setAttribute('sprite-gravity', 9.8);


}

// // Get the mesh objects for two sphere entities
// var sphere1 = document.querySelector('#sphere1').getObject3D('mesh');
// var sphere2 = document.querySelector('#sphere2').getObject3D('mesh');

// // Test for intersections between the two sphere geometries
// var intersects = sphere1.geometry.intersect(sphere2.geometry);

// // If there was an intersection, do something
// if (intersects.length > 0) {
//   // Do something
// }

// AFRAME.registerComponent('collision-detection-land', {

//     init: function () {
// 		var spriteMesh = document.querySelector('#sprite').getObject3D('mesh');


  
//     },

//     tick: function (time, timeDelta) {
// 		var objMesh = this.el.getObject3D('mesh');
// 		var intersects = spriteMesh.geometry.intersect(objMesh.geometry);

// 		// If there was an intersection, do something
// 		if (intersects.length > 0) {
//   		  pause();
// 		}
// 	}
//   });
//   AFRAME.registerComponent('collision-detection-collectable', {

//     init: function () {
// 		var spriteMesh = document.querySelector('#sprite').getObject3D('mesh');
//     },

//     tick: function (time, timeDelta) {
// 		var objMesh = this.el.getObject3D('mesh');
// 		var intersects = spriteMesh.geometry.intersect(objMesh.geometry);

// 		// If there was an intersection, do something
// 		if (intersects.length > 0) {
//   		  this.el.setAttribute('visible', false);
// 		}
// 	}
//   });
  
// AFRAME.registerComponent('collision-detection', {

//     init: function () {
//       const sprite = document.querySelector('#sprite');
//       const spriteGeometry = sprite.getAttribute('geometry');
//       const spritePosition = sprite.object3D.position;

//       let spriteBoundingVolume;
//       if (spriteGeometry.primitive === 'sphere') {
//         const radius = spriteGeometry.radius;
//         spriteBoundingVolume = new THREE.Sphere(spritePosition, radius);
//       } else if (spriteGeometry.primitive === 'box') {
//         const box = new THREE.Box3().setFromObject(sprite.object3D);
//         spriteBoundingVolume = box;
// 		console.log(spriteBoundingVolume)
//       }

  
//     },

//     tick: function (time, timeDelta) {
      
//         const objGeometry = this.el.getAttribute('geometry');
//         const objPosition = this.el.object3D.position;

//         let objBoundingVolume;

//         if (objGeometry.primitive === 'sphere') {
//           const radius = parseFloat(objGeometry.radius);
//           objBoundingVolume = new THREE.Sphere(objPosition, radius);
	
//         } else if (objGeometry.primitive === 'box') {
//           const box = new THREE.Box3().setFromObject(this.el.object3D);
//           objBoundingVolume = box;
//         }

// 		console.log(objBoundingVolume);

//         if (spriteBoundingVolume && objBoundingVolume) {
//           if (
//             (spriteBoundingVolume instanceof THREE.Sphere &&
//               objBoundingVolume instanceof THREE.Sphere &&
//               spriteBoundingVolume.intersectsSphere(objBoundingVolume)) ||
//             (spriteBoundingVolume instanceof THREE.Box3 &&
//               objBoundingVolume instanceof THREE.Box3 &&
//               spriteBoundingVolume.intersectsBox(objBoundingVolume)) ||
//             (spriteBoundingVolume instanceof THREE.Sphere &&
//               objBoundingVolume instanceof THREE.Box3 &&
//               objBoundingVolume.intersectsSphere(spriteBoundingVolume)) ||
//             (spriteBoundingVolume instanceof THREE.Box3 &&
//               objBoundingVolume instanceof THREE.Sphere &&
//               spriteBoundingVolume.intersectsSphere(objBoundingVolume))
//           ) {
//             this.isColliding = true;
//             if(this.el.getAttribute('obj-type')==='land')
//             {
//                 pause()
//             }
//             if(this.el.getAttribute('obj-type')==='collectable')
//             {
//                 this.el.setAttribute('visible', false);
//             }

//           } else {
//             this.isColliding = false;
//           }
//         }
      
//     },
//   });
